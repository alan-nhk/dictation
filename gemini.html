<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>智能默書助理 (增強版)</title>
    
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans TC", sans-serif;
        }
        .scrollbar-hide::-webkit-scrollbar {
            display: none;
        }
        .scrollbar-hide {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        /* Custom Scrollbar */
        .custom-scrollbar::-webkit-scrollbar {
            width: 6px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #c7c7c7;
            border-radius: 4px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #a0a0a0;
        }
    </style>
</head>
<body class="bg-gray-50 text-gray-800">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- Icons ---
        const Play = ({ size = 24, className = "" }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>;
        const Pause = ({ size = 24, className = "" }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>;
        const RotateCcw = ({ size = 24, className = "" }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 12"></path><path d="M3 3v9h9"></path></svg>;
        const SettingsIcon = ({ size = 24, className = "" }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.1a2 2 0 0 1-1-1.72v-.51a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"></path><circle cx="12" cy="12" r="3"></circle></svg>;
        const CheckCircle = ({ size = 24, className = "" }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></svg>;
        const Volume2 = ({ size = 24, className = "" }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg>;
        const Plus = ({ size = 24, className = "" }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>;
        const History = ({ size = 24, className = "" }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 12"></path><polyline points="3 3 3 12 12 12"></polyline></svg>;
        const Repeat = ({ size = 16, className = "" }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><polyline points="17 1 21 5 17 9"></polyline><path d="M3 11V9a4 4 0 0 1 4-4h14"></path><polyline points="7 23 3 19 7 15"></polyline><path d="M21 13v2a4 4 0 0 1-4 4H3"></path></svg>;
        const Sun = ({ size = 16, className = "" }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>;
        const ListIcon = ({ size = 24, className = "" }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><line x1="8" y1="6" x2="21" y2="6"></line><line x1="8" y1="12" x2="21" y2="12"></line><line x1="8" y1="18" x2="21" y2="18"></line><line x1="3" y1="6" x2="3.01" y2="6"></line><line x1="3" y1="12" x2="3.01" y2="12"></line><line x1="3" y1="18" x2="3.01" y2="18"></line></svg>;

        // --- Constants for LocalStorage ---
        const STORAGE_KEY_WORDS = 'dictation_app_words';
        const STORAGE_KEY_SETTINGS = 'dictation_app_settings';

        // --- App ---
        const App = () => {
            // Load Initial State from LocalStorage
            const loadSavedWords = () => {
                const saved = localStorage.getItem(STORAGE_KEY_WORDS);
                return saved || "蘋果\n香蕉\n橙\n士多啤梨\n西瓜";
            };

            const loadSavedSettings = () => {
                const saved = localStorage.getItem(STORAGE_KEY_SETTINGS);
                if (saved) return JSON.parse(saved);
                return {
                    startCountdown: 3,
                    sameWordInterval: 2,
                    nextWordInterval: 3,
                    repeatCount: 2,
                    speechRate: 1
                };
            };

            const initialSettings = loadSavedSettings();

            // State
            const [textInput, setTextInput] = useState(loadSavedWords());
            const [words, setWords] = useState([]);
            const [newWordInput, setNewWordInput] = useState("");
            
            // Settings State
            const [startCountdown, setStartCountdown] = useState(initialSettings.startCountdown);
            const [sameWordInterval, setSameWordInterval] = useState(initialSettings.sameWordInterval);
            const [nextWordInterval, setNextWordInterval] = useState(initialSettings.nextWordInterval);
            const [repeatCount, setRepeatCount] = useState(initialSettings.repeatCount);
            const [speechRate, setSpeechRate] = useState(initialSettings.speechRate);
            
            const [selectedVoice, setSelectedVoice] = useState(null);
            const [availableVoices, setAvailableVoices] = useState([]);

            // Runtime State
            const [status, setStatus] = useState("idle"); 
            const [currentWordIndex, setCurrentWordIndex] = useState(0);
            const [displayMessage, setDisplayMessage] = useState("");
            const [countdownValue, setCountdownValue] = useState(0);
            const [processingWord, setProcessingWord] = useState("");
            const [isInterrupting, setIsInterrupting] = useState(false);

            // Refs
            const abortControllerRef = useRef(null);
            const wakeLockRef = useRef(null);
            const stateRef = useRef({
                status: "idle",
                wordIndex: 0,
                repeatIndex: 1,
                wordsList: [],
                interruptQueue: []
            });

            // --- Persistence Effects ---
            // Save words whenever textInput changes
            useEffect(() => {
                localStorage.setItem(STORAGE_KEY_WORDS, textInput);
            }, [textInput]);

            // Save settings whenever they change
            useEffect(() => {
                const settings = {
                    startCountdown,
                    sameWordInterval,
                    nextWordInterval,
                    repeatCount,
                    speechRate
                };
                localStorage.setItem(STORAGE_KEY_SETTINGS, JSON.stringify(settings));
            }, [startCountdown, sameWordInterval, nextWordInterval, repeatCount, speechRate]);


            // --- Core Logic Effects ---
            
            // Wake Lock
            useEffect(() => {
                const requestLock = async () => {
                    if ('wakeLock' in navigator) {
                        try {
                            wakeLockRef.current = await navigator.wakeLock.request('screen');
                            console.log('Wake Lock active');
                        } catch (err) {
                            console.warn(`Wake Lock Error: ${err.message}`);
                        }
                    }
                };
                const releaseLock = async () => {
                    if (wakeLockRef.current) {
                        try {
                            await wakeLockRef.current.release();
                            wakeLockRef.current = null;
                        } catch (err) {
                            console.warn(`Wake Lock Release Error: ${err.name}`);
                        }
                    }
                };

                if (status === 'running' || status === 'countdown') {
                    requestLock();
                } else {
                    releaseLock();
                }

                const handleVisibilityChange = () => {
                    if (document.visibilityState === 'visible' && (status === 'running' || status === 'countdown')) {
                        requestLock();
                    }
                };
                document.addEventListener('visibilitychange', handleVisibilityChange);
                return () => {
                    document.removeEventListener('visibilitychange', handleVisibilityChange);
                    if (status !== 'running' && status !== 'countdown') releaseLock();
                };
            }, [status]);

            // Parse Words
            useEffect(() => {
                const parsed = textInput.split(/[\n,，]+/).map(w => w.trim()).filter(w => w.length > 0);
                setWords(parsed);
                if (status === 'idle') {
                    stateRef.current.wordsList = parsed;
                }
            }, [textInput, status]);

            // Load Voices (Optimized for Mandarin Accuracy)
            useEffect(() => {
                const loadVoices = () => {
                    const allVoices = window.speechSynthesis.getVoices();
                    if (allVoices.length === 0) return;

                    const matches = (voice, keywords) => {
                        const searchStr = (voice.name + voice.lang).toLowerCase();
                        return keywords.some(k => searchStr.includes(k.toLowerCase()));
                    };

                    // 1. Cantonese
                    const cantonese = allVoices.filter(v => matches(v, ['HK', 'yue', 'cantonese', '粵']));
                    
                    // 2. Mandarin (Enhanced Logic)
                    // Separate Taiwan/Traditional friendly voices from others
                    let mandarinRaw = allVoices.filter(v => matches(v, ['CN', 'TW', 'zh', 'mandarin', 'putonghua']) && !matches(v, ['HK', 'yue', 'cantonese', '粵']));
                    
                    // Prioritize TW/Taiwan specific voices or known good Microsoft/Apple voices
                    const twKeywords = ['tw', 'taiwan', 'hanhan', 'meijia', 'hsiaoyu', 'yating', 'taipei'];
                    
                    mandarinRaw.sort((a, b) => {
                        const aName = (a.name + a.lang).toLowerCase();
                        const bName = (b.name + b.lang).toLowerCase();
                        const aIsTW = twKeywords.some(k => aName.includes(k));
                        const bIsTW = twKeywords.some(k => bName.includes(k));
                        
                        if (aIsTW && !bIsTW) return -1; // a comes first
                        if (!aIsTW && bIsTW) return 1;  // b comes first
                        return 0;
                    });
                    
                    const mandarin = mandarinRaw;

                    // 3. English
                    let englishRaw = allVoices.filter(v => matches(v, ['en-US', 'US', 'United States', 'en-GB']));
                    const goodEngKeywords = ['google', 'siri', 'samantha', 'microsoft', 'natural', 'premium'];
                    englishRaw.sort((a, b) => {
                        const aScore = goodEngKeywords.some(k => a.name.toLowerCase().includes(k)) ? 1 : 0;
                        const bScore = goodEngKeywords.some(k => b.name.toLowerCase().includes(k)) ? 1 : 0;
                        return bScore - aScore; 
                    });
                    const english = englishRaw;

                    // Combine
                    const filtered = [...cantonese.slice(0, 4), ...mandarin.slice(0, 6), ...english.slice(0, 4)];
                    const unique = Array.from(new Map(filtered.map(v => [v.name, v])).values());
                    const final = unique.length > 0 ? unique : allVoices.slice(0, 10);

                    setAvailableVoices(final);
                    
                    // Auto select saved voice or default
                    const savedVoiceName = localStorage.getItem('dictation_last_voice');
                    const savedVoiceExists = final.find(v => v.name === savedVoiceName);

                    if (savedVoiceExists) {
                        setSelectedVoice(savedVoiceName);
                    } else if (final.length > 0 && !selectedVoice) {
                        // Default priority: Mandarin (TW) -> Cantonese -> English
                        const defaultVoice = mandarin[0] || cantonese[0] || english[0] || final[0];
                        setSelectedVoice(defaultVoice.name);
                    }
                };

                loadVoices();
                window.speechSynthesis.onvoiceschanged = loadVoices;
                return () => {
                    window.speechSynthesis.cancel();
                    if (abortControllerRef.current) abortControllerRef.current.abort();
                };
            }, []);

            // Save Voice Selection
            useEffect(() => {
                if (selectedVoice) {
                    localStorage.setItem('dictation_last_voice', selectedVoice);
                }
            }, [selectedVoice]);

            useEffect(() => {
                stateRef.current.status = status;
            }, [status]);

            // --- Logic Helpers ---
            const wait = (ms, signal) => {
                return new Promise((resolve, reject) => {
                    const timer = setTimeout(resolve, ms);
                    signal.addEventListener('abort', () => {
                        clearTimeout(timer);
                        reject(new Error('Aborted'));
                    });
                });
            };

            const speakWord = (text) => {
                return new Promise((resolve, reject) => {
                    window.speechSynthesis.cancel();
                    
                    // Sanitize text slightly to avoid reading weird symbols if needed
                    const safeText = text.replace(/[:：]/g, ""); 
                    
                    const utterance = new SpeechSynthesisUtterance(safeText);
                    const voice = availableVoices.find(v => v.name === selectedVoice);
                    
                    if (voice) {
                        utterance.voice = voice;
                        // IMPORTANT: Explicitly set lang to avoid polyphone errors
                        utterance.lang = voice.lang; 
                    }
                    
                    utterance.rate = speechRate;
                    
                    utterance.onend = () => resolve();
                    utterance.onerror = (e) => {
                        console.error("Speech error", e);
                        resolve(); // Proceed anyway
                    };
                    
                    window.speechSynthesis.speak(utterance);
                });
            };

            const isEnglishVoice = () => {
                if (!selectedVoice || availableVoices.length === 0) return false;
                const v = availableVoices.find(voice => voice.name === selectedVoice);
                return v && v.lang.toLowerCase().includes('en');
            };

            // --- Core Dictation Logic ---
            const startDictation = async (resume = false) => {
                if (abortControllerRef.current) abortControllerRef.current.abort();
                const controller = new AbortController();
                abortControllerRef.current = controller;
                const signal = controller.signal;

                if (!resume) {
                    if (stateRef.current.wordsList.length === 0) {
                        alert("請輸入默書內容");
                        return;
                    }
                    setStatus("countdown");
                    setCountdownValue(startCountdown);
                    try {
                        for (let i = startCountdown; i > 0; i--) {
                            setCountdownValue(i);
                            await wait(1000, signal);
                        }
                    } catch (err) { return; }
                    
                    stateRef.current.wordIndex = 0;
                    stateRef.current.repeatIndex = 1;
                    stateRef.current.interruptQueue = [];
                }

                setStatus("running");

                try {
                    while (true) {
                        let targetWord = "";
                        let isInterrupt = false;

                        if (stateRef.current.interruptQueue.length > 0) {
                            targetWord = stateRef.current.interruptQueue[0];
                            isInterrupt = true;
                        } else if (stateRef.current.wordIndex < stateRef.current.wordsList.length) {
                            targetWord = stateRef.current.wordsList[stateRef.current.wordIndex];
                            isInterrupt = false;
                        } else {
                            break;
                        }

                        setProcessingWord(targetWord);
                        setIsInterrupting(isInterrupt);
                        if (!isInterrupt) {
                            setCurrentWordIndex(stateRef.current.wordIndex);
                        }
                        
                        const prefix = isInterrupt ? "【插播】" : `第 ${stateRef.current.wordIndex + 1} 個詞`;
                        
                        while (stateRef.current.repeatIndex <= repeatCount) {
                            setDisplayMessage(`${prefix} (第 ${stateRef.current.repeatIndex} 次)`);
                            
                            await speakWord(targetWord);
                            
                            if (signal.aborted) throw new Error('Aborted');

                            if (stateRef.current.repeatIndex < repeatCount) {
                                setDisplayMessage(`${prefix} 等待重複...`);
                                await wait(sameWordInterval * 1000, signal);
                            }
                            stateRef.current.repeatIndex++;
                        }

                        setDisplayMessage(isInterrupt ? "插播完畢，準備返回..." : "準備下一個詞...");
                        await wait(nextWordInterval * 1000, signal);

                        stateRef.current.repeatIndex = 1;
                        if (isInterrupt) {
                            stateRef.current.interruptQueue.shift();
                        } else {
                            stateRef.current.wordIndex++;
                        }
                    }

                    setStatus("finished");
                    
                    const finishText = isEnglishVoice() ? "Dictation Finished" : "默書完成！";
                    const speakText = isEnglishVoice() ? "Dictation Finished" : "默書完成";
                    
                    setDisplayMessage(finishText);
                    speakWord(speakText);

                } catch (error) {
                    // Stopped or Aborted
                }
            };

            const handlePause = () => {
                setStatus("paused");
                if (abortControllerRef.current) abortControllerRef.current.abort();
                window.speechSynthesis.cancel();
                setDisplayMessage("已暫停");
            };

            const handleResume = () => startDictation(true);

            const handleReset = () => {
                setStatus("idle");
                if (abortControllerRef.current) abortControllerRef.current.abort();
                window.speechSynthesis.cancel();
                setCurrentWordIndex(0);
                setDisplayMessage("");
                setCountdownValue(0);
                setIsInterrupting(false);
                setProcessingWord("");
                stateRef.current = { 
                    status: "idle", 
                    wordIndex: 0, 
                    repeatIndex: 1, 
                    wordsList: stateRef.current.wordsList, 
                    interruptQueue: [] 
                };
            };

            const handleAddWord = (e) => {
                e.preventDefault();
                const w = newWordInput.trim();
                if (!w) return;
                const newWords = [...words, w];
                setWords(newWords);
                setTextInput(newWords.join('\n'));
                setNewWordInput("");
                stateRef.current.wordsList = newWords;
            };

            const handleInsertWord = (word) => {
                if (status === 'idle' || status === 'finished') return;
                stateRef.current.interruptQueue.push(word);
            };

            const getVoiceLabel = (v) => {
                let lang = "未知";
                const s = (v.name + v.lang).toLowerCase();
                
                if (s.includes("hk") || s.includes("yue") || s.includes("cantonese") || s.includes("粵")) lang = "粵語";
                // Distinction for label
                else if (s.includes("tw") || s.includes("taiwan") || s.includes("hanhan") || s.includes("meijia")) lang = "國語(台灣)";
                else if (s.includes("cn") || s.includes("china") || s.includes("huihui")) lang = "普通話(大陸)";
                else if (s.includes("zh") || s.includes("mandarin")) lang = "普通話/國語";
                else if (s.includes("us") || s.includes("united states")) lang = "英語(美式)";
                else if (v.lang.includes("en")) lang = "英語";
                
                return `${lang} - ${v.name}`;
            };

            return (
                <div className="min-h-screen bg-gray-50 pb-32 font-sans text-gray-800">
                    {/* Top Bar */}
                    <div className="bg-white shadow-sm sticky top-0 z-20">
                        <div className="max-w-5xl mx-auto px-4 py-3 flex justify-between items-center">
                            <h1 className="text-lg sm:text-xl font-bold text-gray-800 flex items-center gap-2">
                                <span className="bg-indigo-600 text-white p-1.5 rounded-lg"><Volume2 size={20} /></span>
                                智能默書助理 <span className="text-xs bg-indigo-100 text-indigo-700 px-2 py-0.5 rounded-full">Pro</span>
                            </h1>
                            <div className="text-xs text-gray-500 bg-gray-100 px-3 py-1 rounded-full hidden sm:block flex items-center gap-1">
                                {(status === 'running' || status === 'countdown') && <span title="螢幕恆亮中"><Sun size={14} className="text-amber-500 animate-pulse" /></span>}
                                {availableVoices.length > 0 ? `已就緒` : "載入中..."}
                            </div>
                        </div>
                    </div>

                    <div className="max-w-5xl mx-auto px-4 py-6 space-y-6">
                        
                        {/* --- RUNNING MODE UI --- */}
                        {status !== 'idle' && (
                            <div className="space-y-6">
                                {/* Main Display Card */}
                                <div className={`relative bg-gradient-to-br from-indigo-900 to-slate-900 text-white rounded-3xl p-6 sm:p-10 text-center shadow-xl overflow-hidden transition-all duration-300 ${isInterrupting ? 'ring-4 ring-yellow-400' : ''}`}>
                                    
                                    {isInterrupting && (
                                        <div className="absolute top-4 right-4 bg-yellow-400 text-black px-3 py-1 rounded-full text-xs font-bold animate-pulse flex items-center gap-1">
                                            <Repeat size={14}/> 插播中
                                        </div>
                                    )}

                                    {status === 'countdown' ? (
                                        <div className="py-8 animate-pulse">
                                            <div className="text-8xl font-black text-yellow-400 mb-4">{countdownValue}</div>
                                            <div className="text-indigo-200 text-xl">準備開始</div>
                                        </div>
                                    ) : status === 'finished' ? (
                                        <div className="py-4">
                                            <div className="inline-flex items-center justify-center p-4 bg-green-500 rounded-full mb-4 shadow-lg">
                                                <CheckCircle size={48} className="text-white" />
                                            </div>
                                            <div className="text-3xl font-bold text-white mb-2">
                                                {displayMessage}
                                            </div>
                                            <button onClick={handleReset} className="mt-6 bg-white/20 hover:bg-white/30 text-white px-8 py-2 rounded-full font-medium transition-all">
                                                返回設定
                                            </button>
                                        </div>
                                    ) : (
                                        <div className="relative z-10">
                                            <div className="inline-block bg-black/30 backdrop-blur-md px-4 py-1.5 rounded-full text-xs font-medium tracking-wider mb-8 text-indigo-100 border border-white/10">
                                                {status === 'paused' ? '已暫停' : '進行中'}
                                            </div>
                                            
                                            <div className="mb-10">
                                                <div className="text-lg text-indigo-300 mb-2 font-medium">正在朗讀</div>
                                                <div className="text-4xl sm:text-6xl font-bold mb-4 tracking-tight drop-shadow-lg min-h-[4rem]">
                                                    {processingWord}
                                                </div>
                                                <div className="text-xl text-indigo-200 font-medium h-8">
                                                    {displayMessage}
                                                </div>
                                            </div>

                                            {/* Progress Bar */}
                                            <div className="max-w-md mx-auto mb-8 opacity-80">
                                                <div className="flex justify-between text-xs text-indigo-300 mb-2 px-1">
                                                    <span>總進度</span>
                                                    <span>{currentWordIndex + 1} / {stateRef.current.wordsList.length}</span>
                                                </div>
                                                <div className="h-2 bg-gray-700/50 rounded-full overflow-hidden backdrop-blur-sm border border-white/5">
                                                    <div 
                                                        className={`h-full bg-gradient-to-r from-blue-400 to-indigo-400 transition-all duration-500 ease-out`}
                                                        style={{ width: `${((currentWordIndex) / Math.max(stateRef.current.wordsList.length, 1)) * 100}%` }}
                                                    ></div>
                                                </div>
                                            </div>
                                            
                                            <div className="flex justify-center gap-4">
                                                {status === 'running' && (
                                                    <button onClick={handlePause} className="flex items-center gap-2 bg-amber-500 hover:bg-amber-600 text-white px-8 py-3 rounded-full font-bold transition-all shadow-lg hover:shadow-amber-500/30 active:scale-95">
                                                        <Pause size={20} fill="currentColor" /> 暫停
                                                    </button>
                                                )}
                                                {status === 'paused' && (
                                                    <button onClick={handleResume} className="flex items-center gap-2 bg-emerald-500 hover:bg-emerald-600 text-white px-8 py-3 rounded-full font-bold transition-all shadow-lg hover:shadow-emerald-500/30 active:scale-95">
                                                        <Play size={20} fill="currentColor" /> 繼續
                                                    </button>
                                                )}
                                                <button onClick={handleReset} className="flex items-center gap-2 bg-white/10 hover:bg-white/20 text-white px-5 py-3 rounded-full font-medium transition-all border border-white/10 active:scale-95 backdrop-blur-sm">
                                                    <RotateCcw size={18} />
                                                </button>
                                            </div>
                                        </div>
                                    )}
                                </div>

                                {/* Interaction Panel */}
                                <div className="grid md:grid-cols-2 gap-6">
                                    {/* History */}
                                    <div className="bg-white rounded-2xl shadow-sm border border-gray-200 p-5 flex flex-col h-64">
                                        <h3 className="text-gray-700 font-bold mb-3 flex items-center gap-2 text-sm">
                                            <History size={18} className="text-indigo-500" />
                                            點擊已讀單詞以插播
                                        </h3>
                                        <div className="flex-1 overflow-y-auto pr-2 space-y-2 custom-scrollbar">
                                            <div className="flex flex-wrap gap-2">
                                                {words.slice(0, currentWordIndex).map((w, idx) => (
                                                    <button 
                                                        key={`${idx}-${w}`}
                                                        onClick={() => handleInsertWord(w)}
                                                        className="px-3 py-1.5 bg-gray-100 hover:bg-indigo-100 hover:text-indigo-700 hover:border-indigo-200 border border-transparent rounded-lg text-sm transition-colors text-gray-600"
                                                    >
                                                        {w}
                                                    </button>
                                                ))}
                                                {currentWordIndex === 0 && (
                                                    <span className="text-gray-400 text-sm italic py-2">尚未有已讀單詞...</span>
                                                )}
                                            </div>
                                        </div>
                                    </div>

                                    {/* Add Word */}
                                    <div className="bg-white rounded-2xl shadow-sm border border-gray-200 p-5 flex flex-col h-64">
                                        <h3 className="text-gray-700 font-bold mb-3 flex items-center gap-2 text-sm">
                                            <Plus size={18} className="text-green-500" />
                                            追加新詞語
                                        </h3>
                                        <div className="flex-1 flex flex-col justify-center">
                                            <form onSubmit={handleAddWord} className="flex gap-2">
                                                <input 
                                                    type="text" 
                                                    className="flex-1 p-3 bg-gray-50 border border-gray-200 rounded-xl focus:ring-2 focus:ring-green-500 outline-none transition-all"
                                                    placeholder="輸入單詞..."
                                                    value={newWordInput}
                                                    onChange={e => setNewWordInput(e.target.value)}
                                                />
                                                <button 
                                                    type="submit"
                                                    disabled={!newWordInput.trim()}
                                                    className="bg-green-600 hover:bg-green-700 disabled:bg-gray-300 text-white px-5 rounded-xl font-bold transition-colors"
                                                >
                                                    加入
                                                </button>
                                            </form>
                                            <div className="mt-4 text-xs text-gray-400">
                                                * 新加入的詞語會排在隊伍最後面 (第 {words.length + 1} 個)
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        )}

                        {/* --- SETUP MODE UI --- */}
                        <div className={`grid md:grid-cols-2 gap-8 transition-all duration-500 ${status !== 'idle' ? 'hidden' : ''}`}>
                            <div className="bg-white p-6 rounded-2xl shadow-sm border border-gray-100 flex flex-col h-full">
                                <h2 className="font-bold text-gray-700 mb-4 flex items-center gap-2 text-lg">
                                    <span className="flex items-center justify-center w-6 h-6 rounded-full bg-indigo-100 text-indigo-600 text-xs">1</span>
                                    輸入內容 <span className="text-xs font-normal text-gray-400 ml-auto">已自動讀取上次紀錄</span>
                                </h2>
                                <div className="flex-1 relative">
                                    <textarea
                                        className="w-full h-full min-h-[300px] p-4 bg-gray-50 border border-gray-200 rounded-xl focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 outline-none resize-none text-lg leading-relaxed transition-all"
                                        placeholder="在此輸入詞語，用換行分隔..."
                                        value={textInput}
                                        onChange={(e) => setTextInput(e.target.value)}
                                    ></textarea>
                                    <div className="absolute bottom-4 right-4 text-xs font-medium text-gray-400 bg-white px-2 py-1 rounded-md shadow-sm border border-gray-100">
                                        {words.length} 個詞語
                                    </div>
                                </div>
                            </div>

                            <div className="bg-white p-6 rounded-2xl shadow-sm border border-gray-100">
                                <h2 className="font-bold text-gray-700 mb-6 flex items-center gap-2 text-lg">
                                    <SettingsIcon size={20} className="text-indigo-600" />
                                    設定參數
                                </h2>

                                <div className="space-y-8">
                                    <div className="space-y-2">
                                        <label className="text-sm font-semibold text-gray-600">語音選擇</label>
                                        <div className="relative">
                                            <select 
                                                className="w-full p-3 pr-10 bg-gray-50 border border-gray-200 rounded-xl text-gray-700 focus:ring-2 focus:ring-indigo-500 outline-none appearance-none"
                                                value={selectedVoice || ""}
                                                onChange={(e) => setSelectedVoice(e.target.value)}
                                            >
                                                {availableVoices.length === 0 && <option>正在載入語音...</option>}
                                                {availableVoices.map(v => (
                                                    <option key={v.name} value={v.name}>{getVoiceLabel(v)}</option>
                                                ))}
                                            </select>
                                            <div className="absolute right-3 top-1/2 -translate-y-1/2 pointer-events-none text-gray-400">
                                                <Volume2 size={16} />
                                            </div>
                                        </div>
                                        <p className="text-xs text-gray-400 mt-1">
                                            * 推薦選擇標示為「國語(台灣)」的語音以獲得最佳準確度
                                        </p>
                                    </div>

                                    <div className="space-y-6">
                                        <div>
                                            <div className="flex justify-between mb-2">
                                                <label className="text-sm font-medium text-gray-600">語速</label>
                                                <span className="text-xs font-bold text-indigo-600 bg-indigo-50 px-2 py-0.5 rounded">{speechRate}x</span>
                                            </div>
                                            <input type="range" min="0.7" max="1.3" step="0.1" className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-indigo-600" value={speechRate} onChange={(e) => setSpeechRate(parseFloat(e.target.value))} />
                                        </div>

                                        <div>
                                            <div className="flex justify-between mb-2">
                                                <label className="text-sm font-medium text-gray-600">開始前倒數</label>
                                                <span className="text-xs font-bold text-indigo-600 bg-indigo-50 px-2 py-0.5 rounded">{startCountdown} 秒</span>
                                            </div>
                                            <input type="range" min="0" max="10" step="1" className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-indigo-600" value={startCountdown} onChange={(e) => setStartCountdown(parseInt(e.target.value))} />
                                        </div>
                                    </div>

                                    <div className="grid grid-cols-2 gap-4">
                                        <div className="space-y-2">
                                            <label className="block text-sm font-medium text-gray-600">重複間隔</label>
                                            <select className="w-full p-2.5 bg-gray-50 border border-gray-200 rounded-lg text-sm focus:ring-2 focus:ring-indigo-500 outline-none" value={sameWordInterval} onChange={(e) => setSameWordInterval(parseInt(e.target.value))}>
                                                {[...Array(10)].map((_, i) => <option key={i+1} value={i+1}>{i+1} 秒</option>)}
                                            </select>
                                        </div>
                                        <div className="space-y-2">
                                            <label className="block text-sm font-medium text-gray-600">下個詞間隔</label>
                                            <select className="w-full p-2.5 bg-gray-50 border border-gray-200 rounded-lg text-sm focus:ring-2 focus:ring-indigo-500 outline-none" value={nextWordInterval} onChange={(e) => setNextWordInterval(parseInt(e.target.value))}>
                                                {[...Array(10)].map((_, i) => <option key={i+1} value={i+1}>{i+1} 秒</option>)}
                                            </select>
                                        </div>
                                    </div>

                                    <div className="space-y-2">
                                        <label className="text-sm font-medium text-gray-600 block">每個詞重複次數</label>
                                        <div className="flex gap-2">
                                            {[1, 2, 3, 4, 5].map(num => (
                                                <button key={num} onClick={() => setRepeatCount(num)} className={`flex-1 py-2 rounded-lg text-sm font-medium transition-all ${repeatCount === num ? 'bg-indigo-600 text-white shadow-md shadow-indigo-200 scale-105' : 'bg-white border border-gray-200 text-gray-600 hover:bg-gray-50 hover:border-gray-300'}`}>{num}</button>
                                            ))}
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        {/* Word List Table */}
                        <div className="bg-white rounded-2xl shadow-sm border border-gray-200 overflow-hidden">
                            <div className="p-4 bg-gray-50 border-b border-gray-200 flex justify-between items-center">
                                <h3 className="font-bold text-gray-700 flex items-center gap-2">
                                    <ListIcon size={20} className="text-gray-500" />
                                    詞語清單檢視 ({words.length})
                                </h3>
                            </div>
                            <div className="max-h-80 overflow-y-auto custom-scrollbar">
                                <table className="w-full text-sm text-left">
                                    <thead className="text-xs text-gray-500 uppercase bg-gray-100 sticky top-0 z-10">
                                        <tr>
                                            <th className="px-6 py-3 w-16">#</th>
                                            <th className="px-6 py-3">詞語內容</th>
                                            <th className="px-6 py-3 w-32">狀態</th>
                                        </tr>
                                    </thead>
                                    <tbody className="divide-y divide-gray-100">
                                        {words.length === 0 ? (
                                            <tr>
                                                <td colSpan="3" className="px-6 py-8 text-center text-gray-400">
                                                    尚未輸入任何詞語
                                                </td>
                                            </tr>
                                        ) : (
                                            words.map((word, index) => {
                                                let statusText = "等待中";
                                                let statusColor = "text-gray-500";
                                                let rowBg = "hover:bg-gray-50";
                                                
                                                if (status !== 'idle') {
                                                    if (index < currentWordIndex) {
                                                        statusText = "已完成";
                                                        statusColor = "text-green-600";
                                                        rowBg = "bg-gray-50";
                                                    } else if (index === currentWordIndex && status !== 'finished') {
                                                        statusText = "正在朗讀";
                                                        statusColor = "text-indigo-600 font-bold";
                                                        rowBg = "bg-indigo-50";
                                                    }
                                                }
                                                
                                                return (
                                                    <tr key={`${index}-${word}`} className={`${rowBg} transition-colors`}>
                                                        <td className="px-6 py-3 font-mono text-xs text-gray-400">{index + 1}</td>
                                                        <td className="px-6 py-3 font-medium text-gray-700">{word}</td>
                                                        <td className={`px-6 py-3 text-xs ${statusColor}`}>{statusText}</td>
                                                    </tr>
                                                );
                                            })
                                        )}
                                    </tbody>
                                </table>
                            </div>
                        </div>

                        {/* Start Button */}
                        {status === 'idle' && (
                            <div className="fixed bottom-8 left-0 right-0 flex justify-center pointer-events-none px-4">
                                <button onClick={() => startDictation(false)} className="pointer-events-auto flex items-center gap-3 bg-indigo-600 hover:bg-indigo-700 text-white text-lg px-10 py-4 rounded-full font-bold shadow-xl shadow-indigo-500/40 transform transition-all hover:scale-105 active:scale-95 group">
                                    <Play size={24} className="group-hover:translate-x-0.5 transition-transform" /> 開始默書
                                </button>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
